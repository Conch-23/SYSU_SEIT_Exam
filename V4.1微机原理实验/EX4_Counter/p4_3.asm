; ======================================================
; 实验 3.3：带标志的一位计时器 (修正按键灭灯问题)
; 组号：13 (末位显示 3)
; ======================================================

		ORG		0000H
		LJMP	START
		ORG		0003H			; INT0 (K0) 入口
		LJMP	INT0_ISR
		ORG		0013H			; INT1 (K1) 入口
		LJMP	INT1_ISR
		ORG		001BH			; Timer1 入口
		LJMP	TIMER1_ISR
		ORG		0030H

START:	MOV		SP, #60H
		
		; --- 初始化定时器1 (50ms) ---
		MOV		TMOD, #10H		; 定时器1 模式1
		MOV		TH1, #4BH		; 50ms 初值 (11.0592MHz)
		MOV		TL1, #0FDH
		MOV		IE, #8DH		; 1000 1101 (开总中断EA, INT0, INT1, Timer1)
		
		; --- 初始化中断触发方式 ---
		MOV		TCON, #00H		; 低电平触发 (符合按键习惯)
		
		MOV		DPTR, #TABLE	; 指向段码表
		
		; --- 初始化变量 ---
		MOV		R2, #0			; R2: 秒计数器 (0-9)
		MOV		R3, #0			; R3: 50ms 计数器 (0-20)
		MOV		R4, #0			; R4: 运行状态 (0=停, 1=跑)

; ======================================================
; 主循环：只负责显示
; ======================================================
MAIN:	
		ACALL	DISPLAY_FRAME	; 扫描一次数码管
		SJMP	MAIN

; ======================================================
; 通用显示子程序 (刷新一帧)
; 功能：快速扫描两个数码管一次
; ======================================================
DISPLAY_FRAME:
		; --- 1. 显示计数值 (右数第2位 / 第5位) ---
		MOV		P1, #0E9H		; 选中第5位数码管 (1110 1100)
								; 如果你的板子顺序不一样，请修改这里，比如 #0E9H
		MOV		A, R2			; 取当前秒数
		MOVC	A, @A+DPTR		; 查表
		MOV		P0, A			; 显示
		ACALL	DELAY_SHORT		; 短延时

		; --- 关灯消影 ---
		MOV		P0, #0FFH		; 关段选
		
		; --- 2. 显示组号末位 '3' (最右侧 / 第6位) ---
		MOV		P1, #0E8H		; 选中第6位数码管 (1110 1101)
								; 如果你的板子顺序不一样，请修改这里，比如 #0E8H
		MOV		A, #3			; 固定显示数字 '3'
		MOVC	A, @A+DPTR
		MOV		P0, A
		ACALL	DELAY_SHORT

		; --- 关灯消影 ---
		MOV		P0, #0FFH
		RET

; ======================================================
; INT0 (K0): 启动/暂停
; ======================================================
INT0_ISR:
		PUSH	ACC
		PUSH	PSW
		
		; --- 状态翻转逻辑 ---
		CJNE	R4, #0, TO_STOP	; 如果是1(跑)，去停止
		
		; [去启动]
		MOV		R4, #1			; 标记为运行
		SETB	TR1				; 开启定时器
		SJMP	WAIT_K0			; 去等待松手

TO_STOP:
		; [去停止]
		MOV		R4, #0			; 标记为停止
		CLR		TR1				; 关闭定时器

		; --- 【关键修改】等待松手时保持显示 ---
WAIT_K0:
		ACALL	DISPLAY_FRAME	; 这一步让灯别灭！
		JNB		P3.2, WAIT_K0	; 如果按键还没松开，继续循环显示
		
		POP		PSW
		POP		ACC
		RETI

; ======================================================
; INT1 (K1): 复位
; ======================================================
INT1_ISR:
		PUSH	ACC
		PUSH	PSW
		
		MOV		R2, #0			; 秒数清零
		MOV		R3, #0			; 50ms计数清零
		
		; 注意：题目说"如果暂停则清零暂停，如果计时则清零计时"
		; 所以这里只清零数据，不改变 TR1 和 R4 的状态

		; --- 【关键修改】等待松手时保持显示 ---
WAIT_K1:
		ACALL	DISPLAY_FRAME	; 这一步让灯别灭！
		JNB		P3.3, WAIT_K1	; 如果按键还没松开，继续循环显示
		
		POP		PSW
		POP		ACC
		RETI

; ======================================================
; Timer1 ISR: 秒计数
; ======================================================
TIMER1_ISR:
		MOV		TH1, #4BH		; 重装初值
		MOV		TL1, #0FDH
		
		INC		R3				; 50ms计数 + 1
		CJNE	R3, #20, T_EXIT	; 没到20次(1秒)就退出
		
		MOV		R3, #0			; 到了1秒，清零50ms计数
		INC		R2				; 秒数 + 1
		CJNE	R2, #10, T_EXIT	; 没到10秒就退出
		MOV		R2, #0			; 到了10秒，归零
		
T_EXIT:	RETI

; ======================================================
; 短延时 (扫描用)
; ======================================================
DELAY_SHORT:
		MOV		R7, #100
DS_LOOP:DJNZ	R7, DS_LOOP
		RET

; ======================================================
; 数据表 (0-9)
; ======================================================
TABLE:	DB 0C0H, 0F9H, 0A4H, 0B0H, 99H
		DB 92H, 82H, 0F8H, 80H, 90H

		END